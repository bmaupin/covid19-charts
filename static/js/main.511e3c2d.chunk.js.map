{"version":3,"sources":["components/Header.tsx","helpers/ChartDataHelper.ts","components/Chart.tsx","components/Main.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["Header","ChartIntervals","ChartMetrics","ChartTypes","githubIcon","className","d","Group","align","Alignment","LEFT","Heading","RIGHT","href","icon","colours","require","ChartDataHelper","chartType","chartMetric","chartInterval","numCountries","numDates","this","getTopChartData","fetchData","apiData","latestDateWithData","getLatestDateWithData","sortedCountries","getTopChartCountries","chartData","formatDataForChart","fetch","response","json","Active","Recovered","New","Confirmed","i","country","console","log","length","countryData","date","confirmed","recovered","index","interval","previousValue","previousIndex","Object","keys","sort","a","b","calculateActiveMetric","find","item","indexOfLatestDate","findIndex","calculateNewMetric","slice","chartSeries","label","colour","data","yValue","push","x","Date","y","Chart","props","useState","setChartData","useEffect","getData","Top","newChartData","loadChartData","axes","primary","type","position","getSeriesStyle","series","color","originalSeries","tooltip","Main","Weekly","setChartInterval","setChartMetric","_handleChartIntervalButtonClick","newInterval","_handleChartMetricButtonClick","newMetric","active","onClick","Deaths","Daily","Monthly","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.511e3c2d.chunk.js","sourcesContent":["import React from 'react';\nimport { Alignment, Button, Navbar } from '@blueprintjs/core';\n\nimport './Header.css';\n\nfunction Header() {\n  const githubIcon = (\n    <span className=\"bp3-icon\">\n      <svg>\n        <path d=\"M12.007 0C6.12 0 1.1 4.27.157 10.08c-.944 5.813 2.468 11.45 8.054 13.312.19.064.397.033.555-.084.16-.117.25-.304.244-.5v-2.042c-3.33.735-4.037-1.56-4.037-1.56-.22-.726-.694-1.35-1.334-1.756-1.096-.75.074-.735.074-.735.773.103 1.454.557 1.846 1.23.694 1.21 2.23 1.638 3.45.96.056-.61.327-1.178.766-1.605-2.67-.3-5.462-1.335-5.462-6.002-.02-1.193.42-2.35 1.23-3.226-.327-1.015-.27-2.116.166-3.09 0 0 1.006-.33 3.3 1.23 1.966-.538 4.04-.538 6.003 0 2.295-1.5 3.3-1.23 3.3-1.23.445 1.006.49 2.144.12 3.18.81.877 1.25 2.033 1.23 3.226 0 4.607-2.805 5.627-5.476 5.927.578.583.88 1.386.825 2.206v3.29c-.005.2.092.393.26.507.164.115.377.14.565.063 5.568-1.88 8.956-7.514 8.007-13.313C22.892 4.267 17.884.007 12.008 0z\" />\n      </svg>\n    </span>\n  );\n\n  return (\n    <header>\n      <Navbar className=\"bp3-dark\">\n        <Navbar.Group align={Alignment.LEFT}>\n          <Navbar.Heading>COVID-19 Trends</Navbar.Heading>\n        </Navbar.Group>\n        <Navbar.Group align={Alignment.RIGHT}>\n          <a href=\"https://github.com/bmaupin/covid19-trends#readme\">\n            <Button className=\"HeaderButton bp3-minimal\" icon=\"help\" />\n          </a>\n          <a href=\"https://github.com/bmaupin/covid19-trends\">\n            <Button className=\"HeaderButton bp3-minimal\" icon={githubIcon} />\n          </a>\n        </Navbar.Group>\n      </Navbar>\n    </header>\n  );\n}\n\nexport default Header;\n","interface Colours {\n  [key: string]: string;\n}\n\nconst colours: Colours = require('./colours.json');\n\nconst API_URL = 'https://pomber.github.io/covid19/timeseries.json';\n\nexport enum ChartIntervals {\n  Daily = 1,\n  Weekly = 7,\n  // Not technically a month but it's a much simpler implementation and should be good enough...\n  Monthly = 30,\n}\n\nexport enum ChartMetrics {\n  Active = 'active',\n  Confirmed = 'confirmed',\n  Deaths = 'deaths',\n  New = 'new',\n  Recovered = 'recovered',\n}\n\nexport enum ChartTypes {\n  Top,\n}\n\ninterface ChartDatum {\n  x: Date;\n  y: number;\n}\n\nexport interface ChartSeries {\n  label: string;\n  data: ChartDatum[];\n  colour: string;\n}\n\nexport interface ChartData extends Array<ChartSeries> {}\n\ninterface ApiCountryData {\n  date: string;\n  confirmed: number;\n  deaths: number;\n  recovered: number;\n}\n\ninterface ApiData {\n  [key: string]: Array<ApiCountryData>;\n}\n\nexport class ChartDataHelper {\n  static async getData(\n    chartType: ChartTypes,\n    chartMetric: ChartMetrics,\n    chartInterval: ChartIntervals,\n    numCountries: number,\n    numDates: number\n  ): Promise<ChartData> {\n    switch (chartType) {\n      default:\n        return await this.getTopChartData(\n          chartMetric,\n          chartInterval,\n          numCountries,\n          numDates\n        );\n    }\n  }\n\n  private static async getTopChartData(\n    chartMetric: ChartMetrics,\n    chartInterval: ChartIntervals,\n    numCountries: number,\n    numDates: number\n  ): Promise<ChartData> {\n    const apiData = await this.fetchData();\n    const latestDateWithData = this.getLatestDateWithData(apiData, chartMetric);\n    const sortedCountries = this.getTopChartCountries(\n      apiData,\n      chartMetric,\n      chartInterval,\n      latestDateWithData,\n      numCountries\n    );\n    const chartData = this.formatDataForChart(\n      apiData,\n      sortedCountries,\n      chartMetric,\n      chartInterval,\n      latestDateWithData,\n      numDates\n    );\n\n    return chartData;\n  }\n\n  private static async fetchData() {\n    const response = await fetch(API_URL);\n\n    return response.json();\n  }\n\n  private static getLatestDateWithData(\n    apiData: ApiData,\n    chartMetric: ChartMetrics\n  ): string | undefined {\n    if (chartMetric === ChartMetrics.Active) {\n      chartMetric = ChartMetrics.Recovered;\n    } else if (chartMetric === ChartMetrics.New) {\n      chartMetric = ChartMetrics.Confirmed;\n    }\n\n    let i = 1;\n    for (const country in apiData) {\n      console.log(country);\n      for (; i <= apiData[country].length; i++) {\n        const countryData = apiData[country][apiData[country].length - i];\n        if (countryData[chartMetric] !== null) {\n          return countryData.date;\n        }\n      }\n    }\n  }\n\n  private static calculateActiveMetric(countryData: ApiCountryData): number {\n    return countryData.confirmed - countryData.recovered;\n  }\n\n  private static calculateNewMetric(\n    apiData: ApiData,\n    country: string,\n    index: number,\n    interval: ChartIntervals\n  ) {\n    let previousValue = 0;\n    const previousIndex = index - 1 * interval;\n    if (previousIndex >= 0) {\n      previousValue = apiData[country][previousIndex].confirmed;\n    }\n\n    return apiData[country][index].confirmed - previousValue;\n  }\n\n  private static getTopChartCountries(\n    apiData: ApiData,\n    chartMetric: ChartMetrics,\n    chartInterval: ChartIntervals,\n    latestDateWithData: string | undefined,\n    numCountries: number\n  ): Array<string> {\n    const sortedCountries = Object.keys(apiData).sort((a, b) => {\n      if (chartMetric === ChartMetrics.Active) {\n        return (\n          this.calculateActiveMetric(\n            apiData[b].find((item) => item.date === latestDateWithData)!\n          ) -\n          this.calculateActiveMetric(\n            apiData[a].find((item) => item.date === latestDateWithData)!\n          )\n        );\n      } else if (chartMetric === ChartMetrics.New) {\n        const indexOfLatestDate = apiData[b].findIndex(\n          (countryData) => countryData.date === latestDateWithData\n        );\n        return (\n          this.calculateNewMetric(\n            apiData,\n            b,\n            indexOfLatestDate,\n            chartInterval\n          ) -\n          this.calculateNewMetric(apiData, a, indexOfLatestDate, chartInterval)\n        );\n      } else {\n        return (\n          apiData[b].find((item) => item.date === latestDateWithData)![\n            chartMetric\n          ] -\n          apiData[a].find((item) => item.date === latestDateWithData)![\n            chartMetric\n          ]\n        );\n      }\n    });\n\n    return sortedCountries.slice(0, numCountries);\n  }\n\n  private static formatDataForChart(\n    apiData: ApiData,\n    sortedCountries: Array<string>,\n    chartMetric: ChartMetrics,\n    chartInterval: ChartIntervals,\n    latestDateWithData: string | undefined,\n    numDates: number\n  ): ChartData {\n    let chartData = [] as ChartData;\n\n    for (const country of sortedCountries) {\n      let chartSeries = {} as ChartSeries;\n      chartSeries.label = country;\n      chartSeries.colour = colours[country];\n\n      chartSeries.data = [];\n\n      const indexOfLatestDate = apiData[country].findIndex(\n        (countryData) => countryData.date === latestDateWithData\n      );\n\n      // TODO: this assumes the data will always be in order\n      for (let i = 0; i < numDates; i++) {\n        const countryData =\n          apiData[country][indexOfLatestDate - i * chartInterval];\n        // countryData could be undefined if we try to get data before the first date due to a large interval\n        if (countryData) {\n          let yValue;\n          if (chartMetric === ChartMetrics.Active) {\n            yValue = this.calculateActiveMetric(countryData);\n          } else if (chartMetric === ChartMetrics.New) {\n            yValue = this.calculateNewMetric(\n              apiData,\n              country,\n              indexOfLatestDate - i * chartInterval,\n              chartInterval\n            );\n          } else {\n            yValue = countryData[chartMetric];\n          }\n\n          // Sometimes the number of total confirmed cases goes down, perhaps as a country corrects its data?\n          // Just set it to zero to keep from throwing the chart scale off\n          if (yValue < 0) {\n            yValue = 0;\n          }\n\n          chartSeries.data.push({\n            x: new Date(countryData.date),\n            y: yValue,\n          });\n        }\n      }\n\n      chartData.push(chartSeries);\n    }\n\n    return chartData;\n  }\n}\n","import React, { useState, useEffect } from 'react';\nimport { Chart as ReactChart } from 'react-charts';\n\nimport './Chart.css';\nimport {\n  ChartMetrics,\n  ChartDataHelper,\n  ChartTypes,\n  ChartData,\n  ChartIntervals,\n} from '../helpers/ChartDataHelper';\n\ninterface IProps {\n  chartInterval: ChartIntervals;\n  chartMetric: ChartMetrics;\n}\n\nfunction Chart(props: IProps) {\n  const axes = [\n    { primary: true, type: 'time', position: 'bottom' },\n    { type: 'linear', position: 'left' },\n  ];\n\n  const [chartData, setChartData] = useState<ChartData | null>(null);\n\n  const _getSeriesStyle = (series: any) => {\n    return {\n      color: series.originalSeries.colour,\n    };\n  };\n\n  useEffect(() => {\n    async function loadChartData() {\n      const newChartData = await ChartDataHelper.getData(\n        ChartTypes.Top,\n        props.chartMetric,\n        props.chartInterval,\n        10,\n        10\n      );\n\n      setChartData(newChartData);\n    }\n\n    loadChartData();\n  }, [props.chartInterval, props.chartMetric]);\n\n  return (\n    // A react-chart hyper-responsively and continuously fills the available\n    // space of its parent element automatically\n    <div className=\"ChartContainer\">\n      <ReactChart\n        axes={axes}\n        data={chartData ? chartData : {}}\n        getSeriesStyle={_getSeriesStyle}\n        tooltip\n      />\n    </div>\n  );\n}\n\nexport default Chart;\n","import React, { useState } from 'react';\n\nimport './Main.css';\nimport Chart from './Chart';\nimport { Button, ButtonGroup } from '@blueprintjs/core';\nimport { ChartIntervals, ChartMetrics } from '../helpers/ChartDataHelper';\n\nfunction Main() {\n  const [chartInterval, setChartInterval] = useState(ChartIntervals.Weekly);\n  const [chartMetric, setChartMetric] = useState(ChartMetrics.New);\n\n  function _handleChartIntervalButtonClick(newInterval: ChartIntervals) {\n    setChartInterval(newInterval);\n  }\n\n  function _handleChartMetricButtonClick(newMetric: ChartMetrics) {\n    setChartMetric(newMetric);\n  }\n\n  return (\n    <div className=\"Main\">\n      <ButtonGroup className=\"ButtonGroup\">\n        <Button\n          active={chartMetric === ChartMetrics.New}\n          onClick={() => _handleChartMetricButtonClick(ChartMetrics.New)}\n        >\n          New\n        </Button>\n        <Button\n          active={chartMetric === ChartMetrics.Confirmed}\n          onClick={() => _handleChartMetricButtonClick(ChartMetrics.Confirmed)}\n        >\n          Confirmed\n        </Button>\n        <Button\n          active={chartMetric === ChartMetrics.Deaths}\n          onClick={() => _handleChartMetricButtonClick(ChartMetrics.Deaths)}\n        >\n          Deaths\n        </Button>\n      </ButtonGroup>\n      <Chart chartInterval={chartInterval} chartMetric={chartMetric} />\n      <ButtonGroup className=\"ButtonGroup\">\n        <Button\n          active={chartInterval === ChartIntervals.Daily}\n          onClick={() => _handleChartIntervalButtonClick(ChartIntervals.Daily)}\n        >\n          Daily\n        </Button>\n        <Button\n          active={chartInterval === ChartIntervals.Weekly}\n          onClick={() => _handleChartIntervalButtonClick(ChartIntervals.Weekly)}\n        >\n          Weekly\n        </Button>\n        {/* Enable the Monthly interval button after we have about 3 months of data (the data starts on 2020-01-22) */}\n        {new Date() > new Date('2020-04-22') && (\n          <Button\n            active={chartInterval === ChartIntervals.Monthly}\n            onClick={() =>\n              _handleChartIntervalButtonClick(ChartIntervals.Monthly)\n            }\n          >\n            Monthly\n          </Button>\n        )}\n      </ButtonGroup>\n    </div>\n  );\n}\n\nexport default Main;\n","import React from 'react';\n\nimport Header from './Header';\nimport Main from './Main';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Header />\n      <Main />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\nimport '@blueprintjs/core/lib/css/blueprint.css';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}